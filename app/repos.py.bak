from app.db import get_connection


def ping_repo() -> bool:
    """Simple sanity function to ensure this module loads cleanly."""
    # do a very cheap check by opening and closing a connection
    with get_connection() as conn:
        # nothing to do; just ensure connection opens
        pass
    return True
from typing import List, Optional, Dict, Any
from app.db import get_connection
from app.models import HymnIn, OpenHeavenIn


def _row_to_dict(row) -> Optional[Dict[str, Any]]:
    if row is None:
        return None
    try:
        return dict(row)
    except Exception:
        return row


# Minimal repositories (core entities). Expand later as needed.
def create_hymn(h: HymnIn) -> int:
    with get_connection() as conn:
        with conn.cursor() as cur:
            cur.execute(
                'INSERT INTO hymns ("hymnTitle","hymnVerse") VALUES (%s,%s) RETURNING id',
                (h.hymnTitle, h.hymnVerse),
            )
            row = cur.fetchone()
            conn.commit()
            return row["id"] if isinstance(row, dict) else row[0]


def list_hymns_paginated(limit: int = 20, offset: int = 0) -> Dict[str, Any]:
    with get_connection() as conn:
        with conn.cursor() as cur:
            cur.execute('SELECT count(*) FROM hymns')
            total = cur.fetchone()[0]
            cur.execute('SELECT * FROM hymns ORDER BY created_at DESC LIMIT %s OFFSET %s', (limit, offset))
            items = cur.fetchall()
            return {"items": items, "total": total, "limit": limit, "offset": offset}


def update_hymn(hymn_id: int, data: dict) -> Optional[dict]:
    if not data:
        return None
    allowed = {"hymnTitle", "hymnVerse"}
    set_parts = []
    values = []
    for k, v in data.items():
        if k not in allowed:
            continue
        set_parts.append(f'"{k}" = %s')
        values.append(v)
    if not set_parts:
        return None
    values.append(hymn_id)
    sql = f'UPDATE hymns SET {",".join(set_parts)} WHERE id=%s RETURNING *'
    with get_connection() as conn:
        with conn.cursor() as cur:
            cur.execute(sql, tuple(values))
            row = cur.fetchone()
            conn.commit()
            return _row_to_dict(row)


def delete_hymn(hymn_id: int) -> bool:
    with get_connection() as conn:
        with conn.cursor() as cur:
            cur.execute('DELETE FROM hymns WHERE id=%s RETURNING id', (hymn_id,))
            row = cur.fetchone()
            conn.commit()
            return bool(row)


# Open Heavens
def create_open_heaven(o: OpenHeavenIn) -> int:
    with get_connection() as conn:
        with conn.cursor() as cur:
            cur.execute(
                'INSERT INTO open_heavens (topic,date,"bibleReading","bibleReadingText","memoryVerse",message,"actionType",hymn,"bible1Year","bible1YearText","actionPoint") VALUES (%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s) RETURNING id',
                (
                    o.topic,
                    o.date,
                    o.bibleReading,
                    o.bibleReadingText,
                    o.memoryVerse,
                    o.message,
                    o.actionType,
                    o.hymn,
                    o.bible1Year,
                    o.bible1YearText,
                    o.actionPoint,
                ),
            )
            row = cur.fetchone()
            conn.commit()
            return row["id"] if isinstance(row, dict) else row[0]


def list_open_heavens_paginated(limit: int = 20, offset: int = 0) -> Dict[str, Any]:
    with get_connection() as conn:
        with conn.cursor() as cur:
            cur.execute('SELECT count(*) FROM open_heavens')
            total = cur.fetchone()[0]
            cur.execute('SELECT * FROM open_heavens ORDER BY date DESC NULLS LAST LIMIT %s OFFSET %s', (limit, offset))
            items = cur.fetchall()
            return {"items": items, "total": total, "limit": limit, "offset": offset}


def update_open_heaven(open_heaven_id: int, data: dict) -> Optional[dict]:
    if not data:
        return None
    allowed = {
        "topic",
        "date",
        "bibleReading",
        "bibleReadingText",
        "memoryVerse",
        "message",
        "actionType",
        "hymn",
        "bible1Year",
        "bible1YearText",
        "actionPoint",
    }
    set_parts = []
    values = []
    for k, v in data.items():
        if k not in allowed:
            continue
        set_parts.append(f'"{k}" = %s')
        values.append(v)
    if not set_parts:
        return None
    values.append(open_heaven_id)
    sql = f'UPDATE open_heavens SET {",".join(set_parts)} WHERE id=%s RETURNING *'
    with get_connection() as conn:
        with conn.cursor() as cur:
            cur.execute(sql, tuple(values))
            row = cur.fetchone()
            conn.commit()
            return _row_to_dict(row)


def delete_open_heaven(open_heaven_id: int) -> bool:
    with get_connection() as conn:
        with conn.cursor() as cur:
            cur.execute('DELETE FROM open_heavens WHERE id=%s RETURNING id', (open_heaven_id,))
            row = cur.fetchone()
            conn.commit()
            return bool(row)
from typing import List, Optional, Dict, Any
from app.db import get_connection
from app.models import HymnIn, OpenHeavenIn, CommentIn, LikeIn, PrayerRequestIn, PrayIn


def _row_to_dict(row) -> Optional[Dict[str, Any]]:
    if row is None:
        return None
    try:
        return dict(row)
    except Exception:
        return row


# Hymns
def create_hymn(h: HymnIn) -> int:
    with get_connection() as conn:
        with conn.cursor() as cur:
            cur.execute(
                'INSERT INTO hymns ("hymnTitle","hymnVerse") VALUES (%s,%s) RETURNING id',
                (h.hymnTitle, h.hymnVerse),
            )
            row = cur.fetchone()
            conn.commit()
            return row["id"] if isinstance(row, dict) else row[0]


def list_hymns_paginated(limit: int = 20, offset: int = 0) -> Dict[str, Any]:
    with get_connection() as conn:
        with conn.cursor() as cur:
            cur.execute('SELECT count(*) FROM hymns')
            total = cur.fetchone()[0]
            cur.execute('SELECT * FROM hymns ORDER BY created_at DESC LIMIT %s OFFSET %s', (limit, offset))
            items = cur.fetchall()
            return {"items": items, "total": total, "limit": limit, "offset": offset}


def update_hymn(hymn_id: int, data: dict) -> Optional[dict]:
    if not data:
        return None
    allowed = {"hymnTitle", "hymnVerse"}
    set_parts = []
    values = []
    for k, v in data.items():
        if k not in allowed:
            continue
        set_parts.append(f'"{k}" = %s')
        values.append(v)
    if not set_parts:
        return None
    values.append(hymn_id)
    sql = f'UPDATE hymns SET {",".join(set_parts)} WHERE id=%s RETURNING *'
    with get_connection() as conn:
        with conn.cursor() as cur:
            cur.execute(sql, tuple(values))
            row = cur.fetchone()
            conn.commit()
            return _row_to_dict(row)


def delete_hymn(hymn_id: int) -> bool:
    with get_connection() as conn:
        with conn.cursor() as cur:
            cur.execute('DELETE FROM hymns WHERE id=%s RETURNING id', (hymn_id,))
            row = cur.fetchone()
            conn.commit()
            return bool(row)


# Open Heavens
def create_open_heaven(o: OpenHeavenIn) -> int:
    with get_connection() as conn:
        with conn.cursor() as cur:
            cur.execute(
                'INSERT INTO open_heavens (topic,date,"bibleReading","bibleReadingText","memoryVerse",message,"actionType",hymn,"bible1Year","bible1YearText","actionPoint") VALUES (%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s) RETURNING id',
                (
                    o.topic,
                    o.date,
                    o.bibleReading,
                    o.bibleReadingText,
                    o.memoryVerse,
                    o.message,
                    o.actionType,
                    o.hymn,
                    o.bible1Year,
                    o.bible1YearText,
                    o.actionPoint,
                ),
            )
            row = cur.fetchone()
            conn.commit()
            return row["id"] if isinstance(row, dict) else row[0]


def list_open_heavens_paginated(limit: int = 20, offset: int = 0) -> Dict[str, Any]:
    with get_connection() as conn:
        with conn.cursor() as cur:
            cur.execute('SELECT count(*) FROM open_heavens')
            total = cur.fetchone()[0]
            cur.execute('SELECT * FROM open_heavens ORDER BY date DESC NULLS LAST LIMIT %s OFFSET %s', (limit, offset))
            items = cur.fetchall()
            return {"items": items, "total": total, "limit": limit, "offset": offset}


def update_open_heaven(open_heaven_id: int, data: dict) -> Optional[dict]:
    if not data:
        return None
    allowed = {"topic", "date", "bibleReading", "bibleReadingText", "memoryVerse", "message", "actionType", "hymn", "bible1Year", "bible1YearText", "actionPoint"}
    set_parts = []
    values = []
    for k, v in data.items():
        if k not in allowed:
            continue
        set_parts.append(f'"{k}" = %s')
        values.append(v)
    if not set_parts:
        return None
    values.append(open_heaven_id)
    sql = f'UPDATE open_heavens SET {",".join(set_parts)} WHERE id=%s RETURNING *'
    with get_connection() as conn:
        with conn.cursor() as cur:
            cur.execute(sql, tuple(values))
            row = cur.fetchone()
            conn.commit()
            return _row_to_dict(row)


def delete_open_heaven(open_heaven_id: int) -> bool:
    with get_connection() as conn:
        with conn.cursor() as cur:
            cur.execute('DELETE FROM open_heavens WHERE id=%s RETURNING id', (open_heaven_id,))
            row = cur.fetchone()
            conn.commit()
            return bool(row)


# Comments
def create_comment(c: CommentIn) -> int:
    with get_connection() as conn:
        with conn.cursor() as cur:
            cur.execute('INSERT INTO comments ("openHeavensId",comment,name) VALUES (%s,%s,%s) RETURNING id',
                        (c.openHeavensId, c.comment, c.name))
            row = cur.fetchone()
            conn.commit()
            return row["id"] if isinstance(row, dict) else row[0]


def list_comments(open_heavens_id: int) -> List[dict]:
    with get_connection() as conn:
        with conn.cursor() as cur:
            cur.execute('SELECT * FROM comments WHERE "openHeavensId"=%s ORDER BY created_at DESC', (open_heavens_id,))
            return cur.fetchall()


# Likes
def create_like(l: LikeIn) -> int:
    with get_connection() as conn:
        with conn.cursor() as cur:
            cur.execute('INSERT INTO likes ("openHeavensId","like",liked) VALUES (%s,%s,%s) RETURNING id',
                        (l.openHeavensId, l.like, l.liked))
            row = cur.fetchone()
            conn.commit()
            return row["id"] if isinstance(row, dict) else row[0]


def count_likes(open_heavens_id: int) -> int:
    with get_connection() as conn:
        with conn.cursor() as cur:
            cur.execute('SELECT count(*) FROM likes WHERE "openHeavensId"=%s AND liked = true', (open_heavens_id,))
            return cur.fetchone()[0]


# Prayers
def create_prayer_request(p: PrayerRequestIn) -> int:
    with get_connection() as conn:
        with conn.cursor() as cur:
            cur.execute('INSERT INTO prayer_requests (name,"userRef",request_content,disabled) VALUES (%s,%s,%s,%s) RETURNING id',
                        (p.name, p.userRef, p.request_content, p.disabled))
            row = cur.fetchone()
            conn.commit()
            return row["id"] if isinstance(row, dict) else row[0]


def list_prayer_requests() -> List[dict]:
    with get_connection() as conn:
        with conn.cursor() as cur:
            cur.execute('SELECT * FROM prayer_requests ORDER BY created_at DESC')
            return cur.fetchall()


def create_pray(p: PrayIn) -> int:
    with get_connection() as conn:
        with conn.cursor() as cur:
            cur.execute('INSERT INTO pray (prayer_content,prayer_request_id,name) VALUES (%s,%s,%s) RETURNING id',
                        (p.prayer_content, p.prayer_request_id, p.name))
            row = cur.fetchone()
            conn.commit()
            return row["id"] if isinstance(row, dict) else row[0]


from typing import List, Optional, Dict, Any
from app.db import get_connection
from app.models import HymnIn, OpenHeavenIn, CommentIn, LikeIn, PrayerRequestIn, PrayIn


def _row_to_dict(row) -> Dict[str, Any]:
    if row is None:
        return None
    try:
        return dict(row)
    except Exception:
        return row


# Hymns
def create_hymn(h: HymnIn) -> int:
    with get_connection() as conn:
        with conn.cursor() as cur:
            cur.execute(
                'INSERT INTO hymns ("hymnTitle","hymnVerse") VALUES (%s,%s) RETURNING id',
                (h.hymnTitle, h.hymnVerse),
            )
            row = cur.fetchone()
            conn.commit()
            return row["id"] if isinstance(row, dict) else row[0]


def list_hymns_paginated(limit: int = 20, offset: int = 0) -> Dict[str, Any]:
    with get_connection() as conn:
        with conn.cursor() as cur:
            cur.execute('SELECT count(*) FROM hymns')
            total = cur.fetchone()[0]
            cur.execute('SELECT * FROM hymns ORDER BY created_at DESC LIMIT %s OFFSET %s', (limit, offset))
            items = cur.fetchall()
            return {"items": items, "total": total, "limit": limit, "offset": offset}


def list_hymns() -> List[dict]:
    return list_hymns_paginated(100, 0)["items"]


def update_hymn(hymn_id: int, data: dict) -> Optional[dict]:
    if not data:
        return None
    allowed = {"hymnTitle", "hymnVerse"}
    set_parts = []
    values = []
    for k, v in data.items():
        if k not in allowed:
            continue
        set_parts.append(f'"{k}" = %s')
        values.append(v)
    if not set_parts:
        return None
    values.append(hymn_id)
    sql = f'UPDATE hymns SET {",".join(set_parts)} WHERE id=%s RETURNING *'
    with get_connection() as conn:
        with conn.cursor() as cur:
            cur.execute(sql, tuple(values))
            row = cur.fetchone()
            conn.commit()
            return _row_to_dict(row)


def delete_hymn(hymn_id: int) -> bool:
    with get_connection() as conn:
        with conn.cursor() as cur:
            cur.execute('DELETE FROM hymns WHERE id=%s RETURNING id', (hymn_id,))
            row = cur.fetchone()
            conn.commit()
            return bool(row)


# Open Heavens
def create_open_heaven(o: OpenHeavenIn) -> int:
    with get_connection() as conn:
        with conn.cursor() as cur:
            cur.execute(
                'INSERT INTO open_heavens (topic,date,"bibleReading","bibleReadingText","memoryVerse",message,"actionType",hymn,"bible1Year","bible1YearText","actionPoint") VALUES (%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s) RETURNING id',
                (
                    o.topic,
                    o.date,
                    o.bibleReading,
                    o.bibleReadingText,
                    o.memoryVerse,
                    o.message,
                    o.actionType,
                    o.hymn,
                    o.bible1Year,
                    o.bible1YearText,
                    o.actionPoint,
                ),
            )
            row = cur.fetchone()
            conn.commit()
            return row["id"] if isinstance(row, dict) else row[0]


def list_open_heavens_paginated(limit: int = 20, offset: int = 0) -> Dict[str, Any]:
    with get_connection() as conn:
        with conn.cursor() as cur:
            cur.execute('SELECT count(*) FROM open_heavens')
            total = cur.fetchone()[0]
            cur.execute('SELECT * FROM open_heavens ORDER BY date DESC NULLS LAST LIMIT %s OFFSET %s', (limit, offset))
            items = cur.fetchall()
            return {"items": items, "total": total, "limit": limit, "offset": offset}


def list_open_heavens() -> List[dict]:
    return list_open_heavens_paginated(100, 0)["items"]


def update_open_heaven(open_heaven_id: int, data: dict) -> Optional[dict]:
    if not data:
        return None
    allowed = {"topic", "date", "bibleReading", "bibleReadingText", "memoryVerse", "message", "actionType", "hymn", "bible1Year", "bible1YearText", "actionPoint"}
    set_parts = []
    values = []
    for k, v in data.items():
        if k not in allowed:
            continue
        set_parts.append(f'"{k}" = %s')
        values.append(v)
    if not set_parts:
        return None
    values.append(open_heaven_id)
    sql = f'UPDATE open_heavens SET {",".join(set_parts)} WHERE id=%s RETURNING *'
    with get_connection() as conn:
        with conn.cursor() as cur:
            cur.execute(sql, tuple(values))
            row = cur.fetchone()
            conn.commit()
            return _row_to_dict(row)


def delete_open_heaven(open_heaven_id: int) -> bool:
    with get_connection() as conn:
        with conn.cursor() as cur:
            cur.execute('DELETE FROM open_heavens WHERE id=%s RETURNING id', (open_heaven_id,))
            row = cur.fetchone()
            conn.commit()
            return bool(row)


# Comments
def create_comment(c: CommentIn) -> int:
    with get_connection() as conn:
        with conn.cursor() as cur:
            cur.execute('INSERT INTO comments ("openHeavensId",comment,name) VALUES (%s,%s,%s) RETURNING id',
                        (c.openHeavensId, c.comment, c.name))
            row = cur.fetchone()
            conn.commit()
            return row["id"] if isinstance(row, dict) else row[0]


def list_comments(open_heavens_id: int) -> List[dict]:
    with get_connection() as conn:
        with conn.cursor() as cur:
            cur.execute('SELECT * FROM comments WHERE "openHeavensId"=%s ORDER BY created_at DESC', (open_heavens_id,))
            return cur.fetchall()


# Likes
def create_like(l: LikeIn) -> int:
    with get_connection() as conn:
        with conn.cursor() as cur:
            cur.execute('INSERT INTO likes ("openHeavensId","like",liked) VALUES (%s,%s,%s) RETURNING id',
                        (l.openHeavensId, l.like, l.liked))
            row = cur.fetchone()
            conn.commit()
            return row["id"] if isinstance(row, dict) else row[0]


def count_likes(open_heavens_id: int) -> int:
    with get_connection() as conn:
        with conn.cursor() as cur:
            cur.execute('SELECT count(*) FROM likes WHERE "openHeavensId"=%s AND liked = true', (open_heavens_id,))
            return cur.fetchone()[0]


# Prayers
def create_prayer_request(p: PrayerRequestIn) -> int:
    with get_connection() as conn:
        with conn.cursor() as cur:
            cur.execute('INSERT INTO prayer_requests (name,"userRef",request_content,disabled) VALUES (%s,%s,%s,%s) RETURNING id',
                        (p.name, p.userRef, p.request_content, p.disabled))
            row = cur.fetchone()
            conn.commit()
            return row["id"] if isinstance(row, dict) else row[0]


def list_prayer_requests() -> List[dict]:
    with get_connection() as conn:
        with conn.cursor() as cur:
            cur.execute('SELECT * FROM prayer_requests ORDER BY created_at DESC')
            return cur.fetchall()


def create_pray(p: PrayIn) -> int:
    with get_connection() as conn:
        with conn.cursor() as cur:
            cur.execute('INSERT INTO pray (prayer_content,prayer_request_id,name) VALUES (%s,%s,%s) RETURNING id',
                        (p.prayer_content, p.prayer_request_id, p.name))
            row = cur.fetchone()
            conn.commit()
            return row["id"] if isinstance(row, dict) else row[0]


from typing import List, Optional
from app.db import get_connection
from app.models import HymnIn, OpenHeavenIn, CommentIn, LikeIn, PrayerRequestIn, PrayIn


def create_hymn(h: HymnIn) -> int:
    with get_connection() as conn:
        with conn.cursor() as cur:
            cur.execute(
                'INSERT INTO hymns ("hymnTitle","hymnVerse") VALUES (%s,%s) RETURNING id',
                (h.hymnTitle, h.hymnVerse),
            )
            row = cur.fetchone()
            conn.commit()
            return row["id"] if isinstance(row, dict) else row[0]


def list_hymns_paginated(limit: int = 20, offset: int = 0) -> dict:
    with get_connection() as conn:
        with conn.cursor() as cur:
            cur.execute('SELECT count(*) FROM hymns')
            total = cur.fetchone()[0]
            cur.execute(
                'SELECT * FROM hymns ORDER BY created_at DESC LIMIT %s OFFSET %s',
                (limit, offset),
            )
            items = cur.fetchall()
            return {"items": items, "total": total, "limit": limit, "offset": offset}


def list_hymns() -> List[dict]:
    return list_hymns_paginated(100, 0)["items"]


def update_hymn(hymn_id: int, data: dict) -> Optional[dict]:
    if not data:
        return None
    set_parts = []
    values = []
    for k, v in data.items():
        set_parts.append(f'"{k}" = %s')
        values.append(v)
    values.append(hymn_id)
    sql = f'UPDATE hymns SET {",".join(set_parts)} WHERE id=%s RETURNING *'
    with get_connection() as conn:
        with conn.cursor() as cur:
            cur.execute(sql, tuple(values))
            row = cur.fetchone()
            conn.commit()
            return row


def delete_hymn(hymn_id: int) -> bool:
    with get_connection() as conn:
        with conn.cursor() as cur:
            cur.execute('DELETE FROM hymns WHERE id=%s RETURNING id', (hymn_id,))
            row = cur.fetchone()
            conn.commit()
            return bool(row)


def create_open_heaven(o: OpenHeavenIn) -> int:
    with get_connection() as conn:
        with conn.cursor() as cur:
            cur.execute(
                'INSERT INTO open_heavens (topic,date,"bibleReading","bibleReadingText","memoryVerse",message,"actionType",hymn,"bible1Year","bible1YearText","actionPoint") VALUES (%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s) RETURNING id',
                (o.topic, o.date, o.bibleReading, o.bibleReadingText, o.memoryVerse, o.message, o.actionType, o.hymn, o.bible1Year, o.bible1YearText, o.actionPoint),
            )
            row = cur.fetchone()
            conn.commit()
            return row["id"] if isinstance(row, dict) else row[0]


def list_open_heavens_paginated(limit: int = 20, offset: int = 0) -> dict:
    with get_connection() as conn:
        with conn.cursor() as cur:
            cur.execute('SELECT count(*) FROM open_heavens')
            total = cur.fetchone()[0]
            cur.execute(
                'SELECT * FROM open_heavens ORDER BY date DESC NULLS LAST LIMIT %s OFFSET %s',
                (limit, offset),
            )
            items = cur.fetchall()
            return {"items": items, "total": total, "limit": limit, "offset": offset}


def list_open_heavens() -> List[dict]:
    return list_open_heavens_paginated(100, 0)["items"]


def update_open_heaven(open_heaven_id: int, data: dict) -> Optional[dict]:
    if not data:
        return None
    set_parts = []
    values = []
    for k, v in data.items():
        set_parts.append(f'"{k}" = %s')
        values.append(v)
    values.append(open_heaven_id)
    sql = f'UPDATE open_heavens SET {",".join(set_parts)} WHERE id=%s RETURNING *'
    with get_connection() as conn:
        with conn.cursor() as cur:
            cur.execute(sql, tuple(values))
            row = cur.fetchone()
            conn.commit()
            return row


def delete_open_heaven(open_heaven_id: int) -> bool:
    with get_connection() as conn:
        with conn.cursor() as cur:
            cur.execute('DELETE FROM open_heavens WHERE id=%s RETURNING id', (open_heaven_id,))
            row = cur.fetchone()
            conn.commit()
            return bool(row)


def create_comment(c: CommentIn) -> int:
    with get_connection() as conn:
        with conn.cursor() as cur:
            cur.execute('INSERT INTO comments ("openHeavensId",comment,name) VALUES (%s,%s,%s) RETURNING id',
                        (c.openHeavensId, c.comment, c.name))
            row = cur.fetchone()
            conn.commit()
            return row["id"] if isinstance(row, dict) else row[0]


def list_comments(open_heavens_id: int) -> List[dict]:
    with get_connection() as conn:
        with conn.cursor() as cur:
            cur.execute('SELECT * FROM comments WHERE "openHeavensId"=%s ORDER BY created_at DESC', (open_heavens_id,))
            return cur.fetchall()


def create_like(l: LikeIn) -> int:
    with get_connection() as conn:
        with conn.cursor() as cur:
            cur.execute('INSERT INTO likes ("openHeavensId","like",liked) VALUES (%s,%s,%s) RETURNING id',
                        (l.openHeavensId, l.like, l.liked))
            row = cur.fetchone()
            conn.commit()
            return row["id"] if isinstance(row, dict) else row[0]


def count_likes(open_heavens_id: int) -> int:
    with get_connection() as conn:
        with conn.cursor() as cur:
            cur.execute('SELECT count(*) FROM likes WHERE "openHeavensId"=%s AND liked = true', (open_heavens_id,))
            return cur.fetchone()[0]


def create_prayer_request(p: PrayerRequestIn) -> int:
    with get_connection() as conn:
        with conn.cursor() as cur:
            cur.execute('INSERT INTO prayer_requests (name,"userRef",request_content,disabled) VALUES (%s,%s,%s,%s) RETURNING id',
                        (p.name, p.userRef, p.request_content, p.disabled))
            row = cur.fetchone()
            conn.commit()
            return row["id"] if isinstance(row, dict) else row[0]


def list_prayer_requests() -> List[dict]:
    with get_connection() as conn:
        with conn.cursor() as cur:
            cur.execute('SELECT * FROM prayer_requests ORDER BY created_at DESC')
            return cur.fetchall()


def create_pray(p: PrayIn) -> int:
    with get_connection() as conn:
        with conn.cursor() as cur:
            cur.execute('INSERT INTO pray (prayer_content,prayer_request_id,name) VALUES (%s,%s,%s) RETURNING id',
                        (p.prayer_content, p.prayer_request_id, p.name))
            row = cur.fetchone()
            conn.commit()
            return row["id"] if isinstance(row, dict) else row[0]


from typing import List, Optional
from app.db import get_connection
from app.models import HymnIn, OpenHeavenIn, CommentIn, LikeIn, PrayerRequestIn, PrayIn

# Hymns

def create_hymn(h: HymnIn) -> int:
    with get_connection() as conn:
        with conn.cursor() as cur:
            cur.execute("INSERT INTO hymns (hymnTitle,hymnVerse) VALUES (%s,%s) RETURNING id",
                        (h.hymnTitle, h.hymnVerse))
            row = cur.fetchone()
            conn.commit()
            return row["id"] if isinstance(row, dict) else row[0]


def list_hymns() -> List[dict]:
    return list_hymns_paginated(100, 0)["items"]


def list_hymns_paginated(limit: int = 20, offset: int = 0) -> dict:
    with get_connection() as conn:
        with conn.cursor() as cur:
            cur.execute('SELECT count(*) FROM "Hymns"')
            total = cur.fetchone()[0]
            cur.execute('SELECT * FROM hymns ORDER BY created_at DESC LIMIT %s OFFSET %s', (limit, offset))
            items = cur.fetchall()
            return {"items": items, "total": total, "limit": limit, "offset": offset}


def update_hymn(hymn_id: int, data: dict) -> Optional[dict]:
    # Build set clause dynamically
    set_parts = []
    values = []
    for k, v in data.items():
        set_parts.append(f'"{k}" = %s')
        values.append(v)
    if not set_parts:
        return None
    values.append(hymn_id)
    sql = f'UPDATE hymns SET {",".join(set_parts)} WHERE id=%s RETURNING *'
    with get_connection() as conn:
        with conn.cursor() as cur:
            cur.execute(sql, tuple(values))
            row = cur.fetchone()
            conn.commit()
            return row


def delete_hymn(hymn_id: int) -> bool:
    with get_connection() as conn:
        with conn.cursor() as cur:
            cur.execute('DELETE FROM hymns WHERE id=%s RETURNING id', (hymn_id,))
            row = cur.fetchone()
            conn.commit()
            return bool(row)

# Open Heavens

def create_open_heaven(o: OpenHeavenIn) -> int:
    with get_connection() as conn:
        with conn.cursor() as cur:
            cur.execute(
                'INSERT INTO open_heavens (topic,date,"bibleReading","bibleReadingText","memoryVerse",message,"actionType",hymn,"bible1Year","bible1YearText","actionPoint") VALUES (%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s) RETURNING id',
                (o.topic, o.date, o.bibleReading, o.bibleReadingText, o.memoryVerse, o.message, o.actionType, o.hymn, o.bible1Year, o.bible1YearText, o.actionPoint)
            )
            row = cur.fetchone()
            conn.commit()
            return row["id"] if isinstance(row, dict) else row[0]


def list_open_heavens() -> List[dict]:
    return list_open_heavens_paginated(100, 0)["items"]


def list_open_heavens_paginated(limit: int = 20, offset: int = 0) -> dict:
    with get_connection() as conn:
        with conn.cursor() as cur:
            cur.execute('SELECT count(*) FROM open_heavens')
            total = cur.fetchone()[0]
            cur.execute('SELECT * FROM open_heavens ORDER BY date DESC NULLS LAST LIMIT %s OFFSET %s', (limit, offset))
            items = cur.fetchall()
            return {"items": items, "total": total, "limit": limit, "offset": offset}


def update_open_heaven(open_heaven_id: int, data: dict) -> Optional[dict]:
    set_parts = []
    values = []
    for k, v in data.items():
        set_parts.append(f'"{k}" = %s')
        values.append(v)
    if not set_parts:
        return None
    values.append(open_heaven_id)
    sql = f'UPDATE open_heavens SET {",".join(set_parts)} WHERE id=%s RETURNING *'
    with get_connection() as conn:
        with conn.cursor() as cur:
            cur.execute(sql, tuple(values))
            row = cur.fetchone()
            conn.commit()
            return row


def delete_open_heaven(open_heaven_id: int) -> bool:
    with get_connection() as conn:
        with conn.cursor() as cur:
            cur.execute('DELETE FROM open_heavens WHERE id=%s RETURNING id', (open_heaven_id,))
            row = cur.fetchone()
            conn.commit()
            return bool(row)

# Comments

def create_comment(c: CommentIn) -> int:
    with get_connection() as conn:
        with conn.cursor() as cur:
            cur.execute('INSERT INTO comments ("openHeavensId",comment,name) VALUES (%s,%s,%s) RETURNING id',
                        (c.openHeavensId, c.comment, c.name))
            row = cur.fetchone()
            conn.commit()
            return row["id"] if isinstance(row, dict) else row[0]


def list_comments(open_heavens_id: int) -> List[dict]:
    with get_connection() as conn:
        with conn.cursor() as cur:
            cur.execute('SELECT * FROM comments WHERE "openHeavensId"=%s ORDER BY created_at DESC', (open_heavens_id,))
            return cur.fetchall()

# Likes

def create_like(l: LikeIn) -> int:
    with get_connection() as conn:
        with conn.cursor() as cur:
            cur.execute('INSERT INTO likes ("openHeavensId","like",liked) VALUES (%s,%s,%s) RETURNING id',
                        (l.openHeavensId, l.like, l.liked))
            row = cur.fetchone()
            conn.commit()
            return row["id"] if isinstance(row, dict) else row[0]


def count_likes(open_heavens_id: int) -> int:
    with get_connection() as conn:
        with conn.cursor() as cur:
            cur.execute('SELECT count(*) FROM likes WHERE "openHeavensId"=%s AND liked = true', (open_heavens_id,))
            return cur.fetchone()[0]

# Prayers

def create_prayer_request(p: PrayerRequestIn) -> int:
    with get_connection() as conn:
        with conn.cursor() as cur:
            cur.execute('INSERT INTO prayer_requests (name,"userRef",request_content,disabled) VALUES (%s,%s,%s,%s) RETURNING id',
                        (p.name, p.userRef, p.request_content, p.disabled))
            row = cur.fetchone()
            conn.commit()
            return row["id"] if isinstance(row, dict) else row[0]


def list_prayer_requests() -> List[dict]:
    with get_connection() as conn:
        with conn.cursor() as cur:
            cur.execute('SELECT * FROM prayer_requests ORDER BY created_at DESC')
            return cur.fetchall()


def create_pray(p: PrayIn) -> int:
    with get_connection() as conn:
        with conn.cursor() as cur:
            cur.execute('INSERT INTO pray (prayer_content,prayer_request_id,name) VALUES (%s,%s,%s) RETURNING id',
                        (p.prayer_content, p.prayer_request_id, p.name))
            row = cur.fetchone()
            conn.commit()
            return row["id"] if isinstance(row, dict) else row[0]
